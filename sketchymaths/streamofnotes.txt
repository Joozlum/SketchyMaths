This text file is not needed for the program to run.
It contains a stream of notes for use to keep track of thoughts while updating the
program.  A way to flesh out ideas and keep track of thoughts on whatever changes
i'm trying to make.

Started a scratch file to put together all of the code for drawing the connections
and their arrows.  The code already works at this point, but the code is ugly,
and it creates lag when there are a lot of equations and lines.  Well, the lag
only occurs when dragging the screen around or zooming in and out, which makes
sense as those actions require updating all of the graphics on the screen.  So
that lag could be coming from a number of sources.

To fix that lag i'm going to try and clean up all of the graphics controls.
The first step is to clean up the code for drawing the connection lines.

Right now the program draws these connections by going through and finding each
reference to another equation inside of the equation text.  This should be a rather
quick operation, though i could probably clean it up some, as these connections
would only need to be searched for when the equation text changes, and since
only one equation can be edited at a time, this would only need to run the check
for that one equation.  I don't think the current method is creating lag though,
as it would require a lot of equations for this method to start slowing down.
...Or would it...

Let's work out two examples for reference...

If there are 5 equations, then each equation would have to search through the text
of 4 equations (skipping a self check, as those shouldn't happen, and if they did
a line wouldn't be drawn anyway).

So with 5 equations, each equation checks 4 other equations, 20 checks.
With 21 equations (for easier head math), each equation would run 20 checks,
so 400 checks.
With 51 equations, each equation would run 50 checks, so 2500 checks.

This is essentially a squared function then.
# of checks = (number_of_equations - 1)^2
This could definitely create lag with a large number of equations, but if there
were that many equations, would this be a significant source of lag?  Each equation
also has graphical instructions to draw the widget, and those could be far more
intensive on the program.  Though, all of those would scale linearly with the
number of equations, so at some point this would become significant, but at what
point would this become significant?
I should add some debugging logs with each of these functions to see how long they
take to process.  Then i would be able to know what is causing the lag.

Okay, so the zoom function takes about .001 with one equation, and about
0.15 with around 100 equations.  That isn't bad, but .15 seconds is noticeable
lag for the user.  Especially since the zoom is done in steps.  When you want to
zoom in your scroll the mousewheel a few time, and each time would be another call
to the zoom function.  I could try to compress this function call, so rather than
doing a bunch of little steps, it could collect the mousewheel and wait for it
to stop before calling, or wait for a threshold.  Probably both.  If you scroll only
once or twice, then it should run for that small zoom, but if you scroll a lot it
should collect those for larger steps.  At the same time, it also would need to have
a threshold, so if you started to scroll a lot, the program wouldn't wait for you to
stop before running a massive zoom.

Going through tutorials on *args and **kwargs.  I already understand them pretty
well, but if i'm going to be able to log information for debugging purposes, it
will help to read up a little more.

More important than all of that though, what i really need to focus on doing is
cleaning up the code as it is now so that it is easier to go through and understand.
Sure, i know what everything here does, but someone else coming to this program
would have a lot of trouble figuring out how everything fit together.